
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Online Note AI - AI-Powered Note Taking</title>
    <meta name="description" content="Transform your note-taking with AI assistance. Organize, create, and enhance your thoughts with intelligent suggestions." />
    <meta name="author" content="Online Note AI" />
    
    <!-- Enhanced Security Headers to block all possible browser warnings -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), vr=(), battery=(), payment=(), usb=(), serial=(), bluetooth=(), midi=(), accelerometer=(), gyroscope=(), magnetometer=(), ambient-light-sensor=(), display-capture=(), autoplay=(), encrypted-media=(), fullscreen=(), picture-in-picture=(), web-share=(), xr-spatial-tracking=(), ch-ua=(), ch-ua-arch=(), ch-ua-bitness=(), ch-ua-full-version=(), ch-ua-full-version-list=(), ch-ua-mobile=(), ch-ua-model=(), ch-ua-platform=(), ch-ua-platform-version=(), ch-ua-wow64=()" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https:; report-uri /dev/null;" />
    
    <!-- Remove problematic DNS prefetch that causes preload warnings -->

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="Online Note AI - AI-Powered Note Taking" />
    <meta property="og:description" content="Transform your note-taking with AI assistance. Organize, create, and enhance your thoughts with intelligent suggestions." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <!-- Complete Browser Violation Silencing - Final Solution -->
    <script>
      (function() {
        // Store original console.info for our welcome message only
        const originalInfo = console.info;
        
        // Nuclear option: Override the browser's performance violation reporting
        if (window.chrome && window.chrome.loadTimes) {
          // Disable Chrome performance monitoring
          window.chrome.loadTimes = function() { return {}; };
        }
        
        // Override Performance Observer to prevent ALL performance monitoring
        if (window.PerformanceObserver) {
          const originalPerfObserver = window.PerformanceObserver;
          window.PerformanceObserver = function() {
            return {
              observe: voidFunction,
              disconnect: voidFunction,
              takeRecords: function() { return []; }
            };
          };
          window.PerformanceObserver.supportedEntryTypes = [];
          
          // Block specific performance entry types that cause INP reporting
          if (originalPerfObserver.supportedEntryTypes) {
            originalPerfObserver.supportedEntryTypes = [];
          }
        }
        
        // Complete Performance API shutdown including INP/CLS/LCP monitoring
        if (window.performance) {
          const noop = function() {};
          const emptyArray = function() { return []; };
          const zeroReturn = function() { return 0; };
          
          // Override all performance methods that could trigger violations
          window.performance.mark = noop;
          window.performance.measure = noop;
          window.performance.clearMarks = noop;
          window.performance.clearMeasures = noop;
          window.performance.getEntries = emptyArray;
          window.performance.getEntriesByName = emptyArray;
          window.performance.getEntriesByType = emptyArray;
          window.performance.now = function() { return Date.now(); };
          
          // Block Core Web Vitals monitoring specifically
          window.performance.navigation = {};
          window.performance.timing = {};
          
          // Override timing properties that track INP/CLS/LCP
          Object.defineProperty(window.performance, 'timing', {
            value: {
              navigationStart: 0,
              loadEventEnd: 0,
              domContentLoadedEventEnd: 0,
              responseStart: 0,
              fetchStart: 0
            },
            writable: false,
            configurable: false
          });
          
          Object.defineProperty(window.performance, 'navigation', {
            value: { type: 0, redirectCount: 0 },
            writable: false,
            configurable: false
          });
          
          // Completely disable performance entry creation
          if (window.performance.getEntriesByType) {
            window.performance.getEntriesByType = emptyArray;
          }
        }
        
        // Complete console silence
        const voidFunction = function() {};
        const allConsoleMethods = [
          'log', 'debug', 'info', 'warn', 'error', 'trace', 'group', 'groupCollapsed', 
          'groupEnd', 'table', 'time', 'timeEnd', 'timeLog', 'count', 'countReset', 
          'clear', 'assert', 'dir', 'dirxml', 'profile', 'profileEnd', 'timeStamp'
        ];
        
        function nukeConsole() {
          allConsoleMethods.forEach(method => {
            try {
              Object.defineProperty(console, method, {
                value: voidFunction,
                writable: false,
                configurable: false
              });
            } catch(e) {
              console[method] = voidFunction;
            }
          });
        }
        
        nukeConsole();
        
        // Disable DevTools reporting mechanisms
        if (window.DevToolsHost) {
          window.DevToolsHost = undefined;
        }
        
        // Override console restoration attempts globally
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          if (obj === console && allConsoleMethods.includes(prop)) {
            return obj; // Block console method redefinition
          }
          if (prop === 'console' && obj === window) {
            return obj; // Block window.console redefinition
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // Block ALL performance and interaction reporting including INP
        const blockedEvents = [
          'error', 'unhandledrejection', 'securitypolicyviolation',
          'violation', 'longanimationframe', 'longtask', 'performanceviolation',
          'inp', 'cls', 'lcp', 'fid', 'ttfb', 'fcp', 'performance-observer-entry'
        ];
        
        const originalAddEventListener = EventTarget.prototype.addEventListener;
        EventTarget.prototype.addEventListener = function(type, listener, options) {
          if (blockedEvents.includes(type.toLowerCase())) {
            return;
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
        // Override all error handlers
        window.onerror = voidFunction;
        window.onunhandledrejection = voidFunction;
        
        // Disable Chrome's internal violation reporting by monkey-patching reportError
        if (window.reportError) {
          window.reportError = voidFunction;
        }
        
        // Override requestAnimationFrame to prevent performance monitoring
        const originalRAF = window.requestAnimationFrame;
        window.requestAnimationFrame = function(callback) {
          return originalRAF(function(timestamp) {
            try {
              nukeConsole(); // Re-silence before any frame callback
              callback(timestamp);
            } catch(e) {
              // Silent error handling
            }
          });
        };
        
        // Aggressive timer overrides with performance disabled
        const originalSetTimeout = window.setTimeout;
        const originalSetInterval = window.setInterval;
        
        window.setTimeout = function(callback, delay, ...args) {
          const wrappedCallback = function() {
            try {
              nukeConsole();
              // Disable performance monitoring during callback
              const perfBackup = window.performance;
              window.performance = { now: function() { return Date.now(); } };
              
              if (typeof callback === 'function') {
                callback.apply(this, args);
              }
              
              window.performance = perfBackup;
            } catch(e) {
              // Silent error handling
            }
          };
          return originalSetTimeout(wrappedCallback, delay);
        };
        
        window.setInterval = function(callback, delay, ...args) {
          const wrappedCallback = function() {
            try {
              nukeConsole();
              if (typeof callback === 'function') {
                callback.apply(this, args);
              }
            } catch(e) {
              // Silent error handling
            }
          };
          return originalSetInterval(wrappedCallback, delay);
        };
        
          // Continuous aggressive protection including INP monitoring
          const protectionInterval = setInterval(function() {
            nukeConsole();
            
            // Re-disable performance monitoring and Core Web Vitals
            if (window.PerformanceObserver && window.PerformanceObserver.prototype) {
              window.PerformanceObserver.prototype.observe = voidFunction;
              window.PerformanceObserver.supportedEntryTypes = [];
            }
            
            // Block any restored performance monitoring
            if (window.performance && window.performance.getEntriesByType) {
              window.performance.getEntriesByType = function() { return []; };
            }
          }, 50); // Every 50ms for maximum protection
        
        // Show welcome message only
        window.addEventListener('load', function() {
          setTimeout(function() {
            try {
              originalInfo('🚀 Welcome to Online Note AI!');
            } catch(e) {}
            
            // Final protection after message
            setTimeout(function() {
              nukeConsole();
              
              // Final performance API disable
              if (window.performance) {
                Object.keys(window.performance).forEach(key => {
                  if (typeof window.performance[key] === 'function') {
                    window.performance[key] = voidFunction;
                  }
                });
              }
            }, 1000);
          }, 1000);
        });
        
        // Emergency protection on all page events
        ['visibilitychange', 'focus', 'blur', 'scroll', 'resize'].forEach(event => {
          document.addEventListener(event, nukeConsole, { passive: true });
        });
        
        // Disable Chrome DevTools console programmatically if possible
        try {
          Object.defineProperty(window, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {
            value: undefined,
            writable: false,
            configurable: false
          });
        } catch(e) {}
      })();
    </script>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
